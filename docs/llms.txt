# Arquitetura de Computadores

## Introdu√ß√£o

A arquitetura de computadores √© um campo fundamental da ci√™ncia da computa√ß√£o que estuda a estrutura, o funcionamento e a organiza√ß√£o dos sistemas computacionais. Ela abrange desde os componentes f√≠sicos (hardware) at√© os aspectos l√≥gicos (software) que permitem a execu√ß√£o de tarefas e processamento de informa√ß√µes. Compreender a arquitetura de computadores √© essencial para o desenvolvimento de sistemas eficientes, otimizados e capazes de atender √†s demandas tecnol√≥gicas atuais.

Este documento explora os principais conceitos da arquitetura de computadores, come√ßando pelos elementos computacionais, que incluem tanto o hardware quanto o software. Em seguida, abordamos os sistemas num√©ricos, essenciais para a representa√ß√£o e manipula√ß√£o de dados em computadores, com destaque para os sistemas bin√°rio, octal e hexadecimal. Tamb√©m discutimos os componentes b√°sicos de um PC, como a CPU, mem√≥ria e dispositivos de entrada e sa√≠da, que formam a base de qualquer sistema computacional.

Al√©m disso, s√£o apresentados conceitos fundamentais de l√≥gica digital, como tabelas verdade e portas l√≥gicas, que s√£o a base para a constru√ß√£o de circuitos eletr√¥nicos e processadores. A organiza√ß√£o interna do processador, incluindo a Unidade Central de Processamento (CPU), registradores e barramentos, √© detalhada para fornecer uma vis√£o clara de como os dados s√£o processados e transferidos dentro de um computador.

Por fim, s√£o explorados os dispositivos de entrada e sa√≠da (E/S), que permitem a intera√ß√£o entre o usu√°rio e a m√°quina, e as diferentes formas de comunica√ß√£o entre esses dispositivos e a CPU. Este documento serve como um guia introdut√≥rio para estudantes e profissionais que desejam compreender os fundamentos da arquitetura de computadores e sua aplica√ß√£o no desenvolvimento de sistemas modernos.



# 2 Elementos Computacionais

Temos que primeiro definir o que √© um `computador`. Ele √© uma m√°quina que recebe determinadas entradas e, com base em seus `algoritmos`, produz determinadas sa√≠das.

Tip:

Algoritmos s√£o sequ√™ncias de instru√ß√µes l√≥gicas e finitas ‚öôÔ∏è

Os elementos s√£o:

* Software

* Hardware

## Softwares

* Parte l√≥gica do computador, s√£o os algoritmos

Tip:

Aquilo que voc√™ xinga
![Tela azul da morte windows versao nana gouveia](images/Tela-azul-da-morte-Windows-versao-Nana-Gouveia.jpg)

## Hardware

* Parte f√≠sica da m√°quina, aquela em que √© usada para transmitir, guardar e ser o esqueleto do computador.

Tip:

Aquilo que voc√™ chuta
![0e5d5a1a6a8bf2f10c4a715125466045](images/0e5d5a1a6a8bf2f10c4a715125466045.gif)

### Elementos de Hardware üîß

Eles s√£o classificados em 3 tipos b√°sicos e essenciais:

```
Processador ->  hardware do Computador  <- Mem√≥ria
                         /\
                          |
                     Entrada/Sa√≠da
```

## Os computadores se dividem em dois tipos: üîñ

Eles s√£o divididos com base na sua forma de funcionamento: anal√≥gico e digital, onde:

### Anal√≥gicos:

√â o tipo de computador em que ele trabalha de maneira que n√£o usa n√∫meros e sim outras formas, como unicamente dois valores de uma corrente de energia.

### 

Digital:

Aquele que usa um sistema de d√≠gitos, ou seja, usam n√∫meros (sendo de uma base bin√°ria: 0 e 1). üî¢

```
[ Anal√≥gico ] => Medem 
[  Digital  ] => Calcula
```

## Gera√ß√µes de Computadores üï∞Ô∏è

Os computadores podem ser divididos em gera√ß√µes por causa da tecnologia que eles usam.

### Gera√ß√£o Zero

Gera√ß√£o base, foi at√© a Segunda Guerra (1932 - 1945), os computadores eram:

* Essencialmente mec√¢nicos e alguns tinham engrenagens eletromec√¢nicas.

* Exemplos: M√°quina de Pascal

![Pasted image 20240908191302.png](images/Pasted%20image%2020240908191302.png)
Note:

Assista esse v√≠deo sobre como funcionava a m√°quina:

[Video](https://www.youtube.com/v/watch?app=desktop&v=CJ7o-ir4R_E)

### Primeira Gera√ß√£o

Gera√ß√£o que apareceu impulsionada pela segunda grande guerra (1945 - 1955)

* Essencialmente usaram as `v√°lvulas`, usando-as ao inv√©s dos `rel√©s` (um componente mec√¢nico que era mais lento que as v√°lvulas). * Exemplos: ENIAC

![Pasted image 20240908191120](images/Pasted%20image%2020240908191120.png)
Note:

Veja mais sobre o Eniac:

[Video](https://youtube.com/v/6X2B8Z_DCo0?si=9HaGUPZqudxTyKPO)

* Algumas desvantagens de seu uso s√£o: * Que eram enormes, ou seja, ocupavam muito espa√ßo. * Gastavam muita energia. * Pouca confiabilidade.

Esses computadores para entrada/sa√≠da e armazenagem de dados usavam os cart√µes perfurados.

## Modelo de Von Neumann

Foi um matem√°tico que contribuiu para a cria√ß√£o da forma como se faz a arquitetura de computadores. O modelo que ele inventou foi usado como base para os modelos posteriores e que s√£o usados hoje.

Modelo:

```
____________      _______________     
|   ______  Mem√≥ria _________    |
|   |                       |    |
Unidade             Unidade Aritm√©tica e
de Controle            L√≥gica  
                    [ Acumuladores/Comutadores ]
                       |       |
                   Entrada     |
                             Sa√≠da  
```

Tip:

* Veja mais em: [Video](https://youtube.com/v/YCe0mX3r9y4?si=1MMYctW2MN8ZgqVx) [Video](https://youtube.com/v/tZ5W2LpdcEw?si=3jCp89cc3G_sq62c) [Video](https://youtube.com/v/Ml3-kVYLNr8?si=gRpWp494K1TnuYDu)

### Segunda Gera√ß√£o

Tamb√©m conhecida como Gera√ß√£o dos Transistores, logo, deixaram de usar as v√°lvulas e come√ßou o processo de miniaturiza√ß√£o dos componentes eletr√¥nicos.

Assim, temos que os transistores trouxeram:

* Menor tamanho aos computadores.

* Consumo de energia caiu.

* Menos aquecimento.

* Tornou-se mais confi√°vel que as v√°lvulas.

![Pasted image 20240908193336](images/Pasted%20image%2020240908193336.png)
Tip:

Confira em: [Manchester's Experimental Transistor Computer, the First Computer to Use Mainly Transistors as Switches](https://www.historyofinformation.com/detail.php?entryid=4074)

Tip:

üí° Veja mais em: [From Transistors To Tetris Part 1 : Computer Architecture](https://youtu.be/6caLyckwo7U?si=g8uCA5xnOTVmaQWD)

### Terceira Gera√ß√£o

Conhecida pelo advento dos Circuitos Integrados (CI), assim esses circuitos cont√™m v√°rios e v√°rios transistores que est√£o miniaturizados em um √∫nico componente, ent√£o acabou se tornando mais acess√≠vel para os p√∫blicos al√©m dos militares, empresas e universidades.

![Pasted image 20240908194231](images/Pasted%20image%2020240908194231.png)
Tip:

Veja mais:

* [From Transistors To Tetris Part 2 : Building a Modern Computer](https://youtu.be/ti9VVBHljWU?si=zy_5nhGTJ_9yYNdw)

* [From Transistors To Tetris Part 3 : The Central Processing Unit](https://youtu.be/IGHbRfawoCo?si=jylmioc60MxukN3c)

* [From Transistors To Tetris Part 4 : The Memory Unit](https://youtu.be/m0nza32BRl8?si=4aSyB6tCLYT1LVC-)

* [https://computerscience.chemeketa.edu/cs160Reader/HistoryOfComputers/Generation3.html](https://computerscience.chemeketa.edu/cs160Reader/HistoryOfComputers/Generation3.html)

### Quarta Gera√ß√£o (Atual)

A miniaturiza√ß√£o dos chips para uma larga escala e integra√ß√£o dos mesmos. Nasce ent√£o o LSI (Large Scale Integration), visando aumentar o poder de processamento dos `processadores`.

Que por sua vez, nessa gera√ß√£o, tomou o nome de `microprocessadores`, criado inicialmente pela INTEL. Eles vieram como uma solu√ß√£o poderosa que continha todos os componentes que um computador precisava de um processador: unidade central de processamento, controladores de mem√≥ria e de E/S.

![Pasted image 20240908194448](images/Pasted%20image%2020240908194448.png)
Tip:

Fonte: [https://chauman4.weebly.com/fourth-generation-computers.html](https://chauman4.weebly.com/fourth-generation-computers.html)

Tip:

Um ponto importante para levantar √© que dependendo do material ou do escritor
podemos ter mais de 4 gera√ß√µes, o que n√£o est√° errado, mas iremos nos abster nessas
quatro que s√£o as principais.



# 3 Sistema Num√©rico

## Sistema de Numera√ß√£o e Convers√µes Entre Bases

### 1. Introdu√ß√£o

Os sistemas de numera√ß√£o s√£o ferramentas essenciais para representar quantidades e realizar c√°lculos matem√°ticos. No dia a dia, utilizamos predominantemente o sistema decimal, com base em 10 s√≠mbolos (0 a 9). No entanto, diversos outros sistemas de numera√ß√£o foram desenvolvidos ao longo da hist√≥ria, cada um com suas caracter√≠sticas e aplica√ß√µes espec√≠ficas.

Neste artigo, exploraremos os principais sistemas de numera√ß√£o utilizados: bin√°rio, octal e hexadecimal, al√©m de abordar as t√©cnicas de convers√£o entre eles.

### 2. Sistema Decimal

O sistema decimal √© o mais utilizado no mundo, com base em 10 s√≠mbolos (0 a 9). Cada posi√ß√£o √† direita do ponto decimal representa uma pot√™ncia de 10. Por exemplo, no n√∫mero 123,456:

* 1 na posi√ß√£o das centenas de milhar (10^5)

* 2 na posi√ß√£o das dezenas de milhar (10^4)

* 3 na posi√ß√£o das unidades de milhar (10^3)

* 4 na posi√ß√£o das centenas (10^2)

* 5 na posi√ß√£o das dezenas (10^1)

* 6 na posi√ß√£o das unidades (10^0)

### 3. Sistema Bin√°rio

O sistema bin√°rio utiliza apenas dois s√≠mbolos: 0 e 1. √â amplamente utilizado na computa√ß√£o digital, pois representa diretamente os estados de um circuito eletr√¥nico (ligado/desligado). Cada posi√ß√£o √† direita do ponto bin√°rio representa uma pot√™ncia de 2. Por exemplo, no n√∫mero 101101:

* 1 na posi√ß√£o das unidades (2^0)

* 0 na posi√ß√£o das dezenas (2^1)

* 1 na posi√ß√£o das centenas (2^2)

* 1 na posi√ß√£o das unidades de milhar (2^3)

* 0 na posi√ß√£o das dezenas de milhar (2^4)

* 1 na posi√ß√£o das centenas de milhar (2^5)

### 4. Sistema Octal

O sistema octal utiliza 8 s√≠mbolos: 0 a 7. √â menos comum que o sistema bin√°rio, mas ainda encontra aplica√ß√µes em algumas √°reas, como em permiss√µes de arquivos em sistemas Unix. Cada posi√ß√£o √† direita do ponto octal representa uma pot√™ncia de 8. Por exemplo, no n√∫mero 12345:

* 1 na posi√ß√£o das unidades (8^0)

* 3 na posi√ß√£o das dezenas (8^1)

* 4 na posi√ß√£o das centenas (8^2)

* 5 na posi√ß√£o das unidades de milhar (8^3)

* 2 na posi√ß√£o das dezenas de milhar (8^4)

### 5. Sistema Hexadecimal

O sistema hexadecimal utiliza 16 s√≠mbolos: 0 a 9 e A a F. √â comumente utilizado em programa√ß√£o e eletr√¥nica, pois permite representar grandes quantidades de dados de forma mais concisa. Cada posi√ß√£o √† direita do ponto hexadecimal representa uma pot√™ncia de 16. Por exemplo, no n√∫mero 1F9A:

* A na posi√ß√£o das unidades (16^0)

* 9 na posi√ß√£o das dezenas (16^1)

* F na posi√ß√£o das centenas (16^2)

* 1 na posi√ß√£o das unidades de milhar (16^3)

### 6. Convers√µes Entre Bases

A convers√£o entre sistemas de numera√ß√£o √© essencial para trabalhar com diferentes representa√ß√µes de dados. Diversas t√©cnicas podem ser utilizadas, como:

* Convers√£o manual: envolve c√°lculos passo a passo, utilizando as defini√ß√µes de cada sistema.

* Calculadoras online: ferramentas online podem realizar convers√µes entre bases de forma r√°pida e precisa.

* Fun√ß√µes de convers√£o em linguagens de programa√ß√£o: linguagens como Python possuem bibliotecas que facilitam a convers√£o entre bases.

### 7. Tabela de Convers√£o Resumida

| Decimal |Bin√°rio |Octal |Hexadecimal |
----------------------------------------
| 0 |0000 |0 |0 |
| 1 |0001 |1 |1 |
| 2 |0010 |2 |2 |
| 3 |0011 |3 |3 |
| 4 |0100 |4 |4 |
| 5 |0101 |5 |5 |
| 6 |0110 |6 |6 |
| 7 |0111 |7 |7 |

Continuando a se√ß√£o sobre convers√µes entre sistemas de numera√ß√£o, apresentamos algumas t√©cnicas para converter manualmente entre decimal, bin√°rio, octal e hexadecimal:

A. Decimal para Bin√°rio:

1. Divida o n√∫mero decimal por 2.

2. Anote o resto da divis√£o (0 ou 1) como o bit menos significativo do n√∫mero bin√°rio.

3. Divida o quociente da divis√£o anterior por 2 e repita os passos 1 e 2.

4. Continue dividindo por 2 e anotando os restos at√© o quociente se tornar 0.

5. Leia os restos da divis√£o na ordem inversa, do √∫ltimo para o primeiro. Essa √© a representa√ß√£o bin√°ria do n√∫mero decimal.

Exemplo: Converter 13 (decimal) para bin√°rio.

1. 13 / 2 = 6 (resto 1)

2. 6 / 2 = 3 (resto 0)

3. 3 / 2 = 1 (resto 1)

4. 1 / 2 = 0 (resto 1)

Lendo os restos na ordem inversa: 1101 (bin√°rio).

B. Bin√°rio para Decimal:

1. Cada bit na representa√ß√£o bin√°ria tem um peso equivalente a uma pot√™ncia de 2 (come√ßando em 2^0 para o bit menos significativo).

2. Multiplique cada bit pelo seu peso correspondente.

3. Some os resultados das multiplica√ß√µes.

Exemplo: Converter 1011 (bin√°rio) para decimal.

1. 1 * 2^3 = 8

2. 0 * 2^2 = 0

3. 1 * 2^1 = 2

4. 1 * 2^0 = 1

Soma: 8 + 0 + 2 + 1 = 11 (decimal).

C. Decimal para Octal:

1. Divida o n√∫mero decimal por 8.

2. Anote o resto da divis√£o como o d√≠gito menos significativo do n√∫mero octal.

3. Divida o quociente da divis√£o anterior por 8 e repita os passos 1 e 2.

4. Continue dividindo por 8 e anotando os restos at√© o quociente se tornar 0.

5. Leia os restos da divis√£o na ordem inversa, do √∫ltimo para o primeiro. Essa √© a representa√ß√£o octal do n√∫mero decimal.

D. Octal para Decimal:

1. Cada d√≠gito na representa√ß√£o octal tem um peso equivalente a uma pot√™ncia de 8 (come√ßando em 8^0 para o d√≠gito menos significativo).

2. Multiplique cada d√≠gito pelo seu peso correspondente.

3. Some os resultados das multiplica√ß√µes.

E. Decimal para Hexadecimal:

1. Divida o n√∫mero decimal por 16.

2. Anote o resto da divis√£o como o d√≠gito menos significativo do n√∫mero hexadecimal (0 a 9, A a F).

* Se o resto for maior que 9, use a letra correspondente (A para 10, B para 11, etc.).

3. Divida o quociente da divis√£o anterior por 16 e repita os passos 1 e 2.

4. Continue dividindo por 16 e anotando os restos at√© o quociente se tornar 0.

5. Leia os restos da divis√£o na ordem inversa, do √∫ltimo para o primeiro. Essa √© a representa√ß√£o hexadecimal do n√∫mero decimal.

F. Hexadecimal para Decimal:

1. Cada d√≠gito na representa√ß√£o hexadecimal tem um peso equivalente a uma pot√™ncia de 16 (come√ßando em 16^0 para o d√≠gito menos significativo).

2. Multiplique cada d√≠gito pelo seu peso correspondente (A = 10, B = 11, etc.).

3. Some os resultados das multiplica√ß√µes.

Estas s√£o apenas algumas t√©cnicas b√°sicas de convers√£o. Existem outras abordagens e tabelas de convers√£o que podem ser utilizadas para facilitar o processo.



# 4 Componentes b√°sicos de um PC

Nesse caso iremos abordar por um lado do hardware, ou seja, parte f√≠sica.

## Componentes:

* S√£o eles:

```
CPU | Memoria | Dispositivos de Entrada e S√°ida | Barramentos
```

* Esses componenetes s√£o conectados por `Barrramentos` (s√£o 'estradas' ou cabos que ligam os componenetes)

```
----------------------
CPU  | Memoria | E/S |
----------------------
 |       |         |
 |       |         |
---------------------
|   Barrramentos    |
---------------------
```

### CPU

CPU √© a Unidade de Processamento Central ele executa, processa os dados e atividades a serem feitas

### Memoria

Memoria √© a responsavel de guardar as informa√ß√µes do computador sendo as informa√ß√µes volateis ou n√£o volateis

Tip:

Memoria volateis √© aquela que precisa armazenar informa√ß√µes at√© o momento em ue o PC est√° ligado. Agora memorias n√£o volateis guardam as informa√ß√µes mesmo desligando o computador.

* Existem dois tipos de classifica√ß√£o de memorias em rela√ß√£o a sua ordem. Sendo elas: * Ordem Primaria = s√£o memorias responsaveis por guardar os programas a serem executados e outras informa√ß√µes importantes, focasdas em serem acessads * Exemplo: RAM, Cache * Ordem Secundaria = s√£o memorias que armazenam os dados permanentemente, focadas em apenas armazenar * Exemplo: HD, SSD

### E/S

S√£o dispositivos responsaveis pela intera√ß√£o `humano` e `computador`.
servindo para entrar e sair com dados.

* Exemplos * Entrada: WEBCAM, Teclado, Mouse * Sa√≠da: Monitor, Caixa de Som

### Barrramento

s√£o fios ou caminhos condutores que passam pelo computador e interligam os componentes.



# 5 Tabela Verdade

## O que seria Tabela Verdade?

Tabela Verdade √© a forma como podemos obter valores de express√µes booleanas de todas as poss√≠veis combina√ß√µes.

Tip:

Express√µes Booleanas s√£o aquelas que possuem apenas dois valores l√≥gicos: verdadeiro (true) ou falso (false).

Ajuda na constru√ß√£o de circuitos e na verifica√ß√£o de preposi√ß√µes l√≥gicas.

## L√≥gica Proposicional

√â a linguagem que usamos para manipular `proposi√ß√µes`.

### Proposi√ß√£o

S√£o afirma√ß√µes que podem ser avaliadas em dois valores √∫nicos: `verdadeiro` ou `falso`. Pode-se tipificar as proposi√ß√µes de dois tipos: `simples` e `compostas`;
Elas possuem uma regra de representa√ß√£o, que √©: devem usar letras min√∫sculas

Tip:

Normalmente se usa: `p`, `q`, `r`, etc

* Exemplo: p = Sou o Douglas; q = Voc√™ n√£o √© o Douglas

#### Simples

√â quando existe uma √∫nica proposi√ß√£o.

* Exemplo: Est√° chovendo (verdadeiro ou Falso)

#### Compostas

√â quando se tem mais de uma proposi√ß√£o, ligadas por `conectivos l√≥gicos`.

* Exemplo: Est√° chovendo ou est√° nublado (com o uso do `ou` liga duas proposi√ß√µes e assim estabelece determinada regra do conectivo que est√° sendo usado)

### Conectivos L√≥gicos

S√£o part√≠culas usadas para combinar e modificar proposi√ß√µes e assim criar express√µes booleanas

#### Alguns Conectivos

* Nega√ß√£o (¬¨ ou ~): ele nega a senten√ßa, logo o que √© verdadeiro fica falso e o que √© falso se torna verdadeiro. * Exemplo: p = Gustavo √© antissocial; ~p = Gustavo n√£o √© antissocial

| p |~p |
---------
| V |F |
| F |V |
| V |F |
| F |V |

* Conjuntivo (^): esse conectivo diz que para ser verdadeiro as duas devem ser verdadeiras * Exemplo: p = verdadeiro; q = verdadeiro; p ^ q = Verdadeiro

| p |q |p ^ q |
---------------
| v |f |f |
| f |v |f |
| v |v |v |
| f |f |f |

* Disjun√ß√£o (v): √© um conectivo em que apenas uma precisa ser verdadeira para que a express√£o resulte em verdadeiro. * Exemplo: p = verdadeiro; q = falso; p v q = verdadeiro

| p |q |p v q |
---------------
| v |f |v |
| f |v |v |
| v |v |v |
| f |f |f |

* Condicional (se...ent√£o) (->): √© um conectivo que baseia-se em que para ser verdadeiro, a condi√ß√£o `p` deve ser verdadeira para que a proposi√ß√£o `q` seja verdadeira. * Exemplo: p = verdadeiro; q = verdadeiro; p -> q = verdadeiro

| p |q |p -> q |
----------------
| v |f |f |
| f |v |v |
| v |v |v |
| f |f |v |

* Bicondicional (se somente se) (<->): √© um conectivo que a condi√ß√£o estabelecida equivale para as duas proposi√ß√µes, ou seja, ser√° verdadeiro se as duas forem atendidas. * Exemplo: p = Vou gastar; q = ter dinheiro; p <-> q = verdadeiro = Vou gastar, se somente se, tiver dinheiro

| p |q |p <-> q |
-----------------
| v |f |f |
| f |v |f |
| v |v |v |
| f |f |v |

#### Tabela de Conectivos

| Conectivo |Valor |
--------------------
| ~ |Ser√° verdadeiro se for falso e falso se for verdadeiro |
| ^ |Ser√° verdadeiro se ambas forem verdadeiras |
| v |Se uma ou as duas forem verdadeiras ent√£o resulta em verdadeiro |
| -> |Se a primeira for verdadeira e a segunda for falsa ent√£o resulta em falso, sen√£o √© verdadeiro |
| <-> |S√≥ ser√° verdadeiro se as duas tiverem o mesmo valor, sen√£o √© falso |



# 6 Portas L√≥gicas

Os computadores s√£o constitu√≠dos de elementos eletr√¥nicos como: capacitores, resistores e transistores.

* Capacitores: s√£o os componentes respons√°veis por armazenar e liberar carga el√©trica, realizando a filtragem de ru√≠do e a estabiliza√ß√£o de tens√µes.

* Resistores: limitam a passagem de corrente el√©trica e s√£o usados para controlar a voltagem da corrente el√©trica.

* Transistores: amplificam sinais e controlam o fluxo da corrente dentro do circuito. Eles permitem ou n√£o a passagem de sinais bin√°rios para realizarem opera√ß√µes atrav√©s das portas l√≥gicas, formando assim os `circuitos l√≥gicos`.

Portas L√≥gicas s√£o a base para a constru√ß√£o de um processador. Elas s√£o embutidas em um CI (Circuito Integrado) com o objetivo de realizar tarefas espec√≠ficas. Podem ser encontradas tanto em ULSI (Ultra Large Scale Integration) quanto em circuitos mais simples.

## √Ålgebra de Comuta√ß√£o

Assim como a √°lgebra b√°sica da escola, criou-se a necessidade de fazer opera√ß√µes com os d√≠gitos bin√°rios. Surge ent√£o a √Ålgebra de Comuta√ß√£o.

Para tal, era necess√°rio primeiro definir as representa√ß√µes gr√°ficas. Adotou-se ent√£o 0 (falso) e 1 (verdadeiro).

### Porta AND

Esta porta aceita dois operandos: A e B, sendo bin√°rios 0 e 1.
A opera√ß√£o AND simula a multiplica√ß√£o bin√°ria, possuindo a finalidade de garantir que o mesmo bit de entrada seja o mesmo da sa√≠da (transfer√™ncia de bit, ou seja, √© usado para transferir dados da mem√≥ria para a CPU).

* Porta L√≥gica AND:

| Entrada |Sa√≠da |  |
---------------------
| A |B |Y = AB |
| 1 |0 |0 |
| 0 |1 |0 |
| 1 |1 |1 |
| 0 |0 |0 |

### Porta OR

Esta porta aceita dois operandos: A e B, sendo bin√°rios 0 e 1.
Ela simula a soma bin√°ria, ou seja, s√≥ resultar√° em verdadeiro (1) se pelo menos um dos operandos for igual a 1.

* Porta L√≥gica OR:

| Entrada |Sa√≠da |  |
---------------------
| A |B |Y = A+B |
| 1 |0 |1 |
| 0 |1 |1 |
| 1 |1 |1 |
| 0 |0 |0 |

### Porta XOR (exclusive or)

Esta porta aceita dois operandos: A e B, sendo bin√°rios 0 e 1.
Ela serve como uma verifica√ß√£o de desigualdade, em que se os operandos tiverem valores bin√°rios diferentes, a opera√ß√£o resultar√° em verdadeiro (1). Caso contr√°rio, resultar√° em falso (0).

* Porta L√≥gica XOR:

| Entrada |Sa√≠da |  |
---------------------
| A |B |Y = A XOR B |
| 1 |1 |0 |
| 0 |1 |1 |
| 1 |0 |1 |
| 0 |0 |0 |

### Porta NOT

Esta porta aceita um operando: A, sendo bin√°rio 0 ou 1.
Ela faz uma invers√£o de valores, ou seja, se o valor do operando for 1, ele se torna 0, e se for 0, ele se torna 1.

* Porta L√≥gica NOT:

| Entrada |Sa√≠da |
------------------
| A |NOT A |
| 1 |0 |
| 0 |1 |

### Portas Derivadas

Tip:

A execu√ß√£o dessas portas se d√° em duas etapas, ou seja, ir√° executar primeiro uma opera√ß√£o e depois a outra.

### Porta NAND

Esta porta aceita dois operandos: A e B, sendo bin√°rios 0 e 1.
Ela faz a opera√ß√£o AND e em seguida realiza a execu√ß√£o do NOT.

* Porta L√≥gica NAND:

| Entrada |Sa√≠da |  |
---------------------
| A |B |Y = A NAND B |
| 1 |0 |1 |
| 0 |1 |1 |
| 1 |1 |0 |
| 0 |0 |1 |

### Porta NOR

Esta porta aceita dois operandos: A e B, sendo bin√°rios 0 e 1.
Ela faz primeiro o OR e em seguida opera o NOT.

* Porta L√≥gica NOR:

| Entrada |  |Sa√≠da |
---------------------
| A |B |Y = A+B |
| 1 |0 |0 |
| 0 |1 |0 |
| 1 |1 |0 |
| 0 |0 |1 |



# 7 Tipos de Mem√≥ria

Primeiro, devemos entender como √© o ciclo das mem√≥rias num computador:

```
-> Ligar -> PC -> Corre na CPU -> Confere a ROM 
-> Vai na mem√≥ria secund√°ria para buscar o SO 
-> Usa a mem√≥ria principal para carregar os programas
```

A Mem√≥ria √© um dispositivo que serve para armazenar dados ou instru√ß√µes para que a CPU use.
Existem dois tipos de mem√≥rias: permanente e n√£o permanente.
As mem√≥rias est√£o interligadas e formam o subsistema de mem√≥rias.

## Pir√¢mide de Mem√≥rias

Pode-se classificar as mem√≥rias com base em algumas propriedades.

* Quanto mais alto: * Mais caro * Mais r√°pido * Baixa capacidade de armazenamento

* Quanto mais baixo: * Mais barato * Menos r√°pido * Alta capacidade de armazenamento

```
              /\
             /  \
            /    \
           / Regis\
          / trador \
         /          \
        /            \ 
       /    Cache     \
      /                \
     /     Mem√≥ria      \
    /      Principal     \
   /     (RAM e ROM)      \
  /                        \
 /    Mem√≥ria Secund√°ria    \
/      (HD, CD/DVD, SSD)     \
-------------------------------
```

## Registradores

O processador busca informa√ß√µes e instru√ß√µes na mem√≥ria e armazena em seu interior o que deve ser feito.
O local onde s√£o armazenados √© denominado `registradores`.

## Cache

O Cache serve para suprir a necessidade do processador de ter uma mem√≥ria auxiliar.
Serve para acelerar a comunica√ß√£o entre o `processador` e a `mem√≥ria principal`.

### Cache L1

√â a primeira a ser buscada, a mem√≥ria cache que est√° dentro do processador, dividida em dois campos:

* L1d: feito para guardar dados

* L1i: feito para guardar instru√ß√µes

### Cache L2

Ao n√£o encontrar o que se procurava na L1, √© feita a busca em L2.
Esta mem√≥ria utiliza o sistema: Static Random Access Memory (SRAM)

Ao n√£o se encontrar no Cache L2, ela √© respons√°vel por chamar a mem√≥ria principal, ou seja, a DRAM (Dynamic Random Access Memory)

## Mem√≥ria Principal

Respons√°vel por alocar informa√ß√µes das aplica√ß√µes executadas no momento em que o PC ainda est√° ligado. Por isso ela precisa ficar refrescando a mem√≥ria, assim ela funciona de modo din√¢mico.
A mem√≥ria principal √© denominada mem√≥ria RAM.

### Padr√µes de RAM

* DDR: este padr√£o tem como caracter√≠stica a duplica√ß√£o de lotes de bits por 1 ciclo de clock, ou seja, 64 bits por 1 ciclo de clock (ida e volta do CPU √† Mem√≥ria) * Ela possui v√°rias vers√µes que mudam em voltagem, lat√™ncia, etc.

### Formato

* DIMM: usadas em desktops, s√£o mais robustas, tudo em uma linha

* SO-DIMM: usadas em laptops, s√£o mais compactas e em v√°rias linhas

### ROM

√â a mem√≥ria que √© apenas para leitura (Read Only Memory = ROM), escrita normalmente pelo fabricante e apenas lida depois. Os programas instalados nela s√£o chamados de firmwares.

Firmwares j√° instalados:

* BIOS: Sistema B√°sico de Entrada e Sa√≠da

* POST: Autoteste e verifica√ß√£o no momento da inicializa√ß√£o

* SETUP: Muda as configura√ß√µes j√° pr√©-definidas

## Mem√≥ria Secund√°ria

√â a mem√≥ria que vai armazenar os dados em massa, ou seja, o `SO` e outros programas, assim como outros dados, e por isso ela n√£o pode ser `vol√°til`.
Essas mem√≥rias n√£o s√£o acessadas diretamente pelo processador.

Tip:

Vol√°til √© igual a: desligou o PC, ela deixou de existir. Como gigolos, acabou o dinheiro, n√£o se v√™ mais ningu√©m.

SO √© o Sistema Operacional, sendo a interface entre hardware, humano e software. Ele √© aquele amigo cupido.



# 8 Organiza√ß√£o do Processador

A CPU √© respons√°vel pelo processamento e execu√ß√£o de programas que est√£o armazenados nela. Ela √© dividida em tr√™s partes:

1. Unidade Central (UC);

2. Registradores;

3. Unidade L√≥gica Aritm√©tica (ULA ou UAL);

Podendo ser dividida em duas partes funcionais:

* Unidade Funcional de Controle; * UC

* Unidade Funcional de Processamento; * ULA e Registradores

## Diagrama de Funcionamento da CPU

```
           Unidade Funcional de Processamento
  -------                -----------------        
  | ULA |                | Registradores |         
  ---|---                | (RISC e CISC) |         
     |                   -----|--------|--         
     |                        |        |           
     |                        |        |           
==== | ====================== | ====== | =================================
     |     -------------      |        |
     |-----| Barramento |-----|        |     
     |-----|  Interno   |-------|------|--|-----------|O------------|
     |     -------------        |         |           |             |
     |                          |         |           |             | 
     |                          |         |           |             |
==== | ======================== | ======= | ========= | =========== | ====
     |                          |         |      -----|------   ---------
     |                          |         |      | B.       |   | B.    |  
     |----|---------------|   --|--    ---|--    | Endere√ßo |   | Dados |
     |    | Decodificador |---| RI |---| CI |    -----|------   ----|---- 
     |    | de Instru√ß√µes |   -----    ------    REM  |         RDM |
     |----|---------------|                           |             | 
     |                                                |             |
   --|---                                      |------O------|      | 
   | UC |--------------------------------------|   Mem√≥ria   O------|
   ------                                      |  Principal  |
                                               |-------------|                                      
        Unidade funcional de Controle                                          

- REM => Registro de Endere√ßos Mem√≥ria
- RDM => Registro de Dados Mem√≥ria
```

## Unidade Funcional de Processamento

Todo sistema operacional possui uma √∫nica fun√ß√£o de exist√™ncia, ou seja, o porqu√™ dele existir e a fun√ß√£o para esses sistemas s√£o: entrar com dados, processar dados, sa√≠da de dados processados, assim nasce a Unidade Funcional de Processamento.

Logo a UFP, possui algumas opera√ß√µes b√°sicas:

* Opera√ß√µes Aritm√©ticas

* √Ålgebra Booleana

* Movimenta√ß√£o de Dados entre a CPU e a Mem√≥ria

### ULA

√â a parte central da CPU j√° que √© onde as opera√ß√µes l√≥gicas e aritm√©ticas ir√£o ser feitas.
Ela n√£o recebe as instru√ß√µes diretamente, e sim as instru√ß√µes s√£o processadas pela UC. Assim que processado, √© enviado para a ULA que realiza o que se pede e retorna o resultado.

### Registradores

√â o tipo de mem√≥ria que √© r√°pida e com pouco armazenamento.
Sendo que varia em sua fun√ß√£o e quantidade de acordo com o modelo do processador.
A maioria dos processadores utilizam a arquitetura baseada em registradores de processos gerais (RISC/CISC):

* RISC (Reduced Instructions Set Computer): * Caracterizado pela simplicidade e efici√™ncia nas execu√ß√µes de instru√ß√µes (voltado mais para dispositivos que exigem menos processamento como dispositivos m√≥veis e laptops);

* CISC (Complex Instructions Set Computer): * Caracterizado por um conjunto de instru√ß√µes mais complexas e abrangentes (voltado para dispositivos que exigem mais poder de processamentos como desktops e servidores);

## Unidade Funcional de Controle

Executa algumas fun√ß√µes:

* Busca de instru√ß√µes a serem executadas e armazenadas em um registrador da CPU;

* Interpretar as instru√ß√µes para serem enviadas √† ULA * Gerar sinais de controle, ao interpretar vai gerar um sinal para a ULA dizendo qual das opera√ß√µes devem ser executadas;

### Contador de Instru√ß√µes (CI)

O Contador de Instru√ß√µes √© aquele que vai registrar a contagem para sequenciamento das instru√ß√µes, ou seja, montar aquela fila de fichas, onde cada ficha possui um n√∫mero de ordem de chamada para que se possa ter o controle das ordens de instru√ß√µes.

### Registrador de Instru√ß√µes (RI)

Este Registrador de Instru√ß√µes possui a fun√ß√£o de armazenar a instru√ß√£o que deve ser executada pela CPU.

### Decodificador de Instru√ß√µes

O RI ir√° passar uma sequ√™ncia de bits representando a instru√ß√£o a ser executada para o Decodificador de Instru√ß√µes que, por sua vez, ir√° interpretar essa sequ√™ncia de bits e relacionar com a opera√ß√£o que deve ser feita. Em seguida, mandar essa instru√ß√£o j√° interpretada para a UC, assim ela manda os sinais necess√°rios para a ULA, por exemplo, do que deve ser feito.

* Diagrama de funcionamento RI e Decod. Instruc.

```
------     _____________      ______
| UC |o----| Decod.    |o-----| RI |
------     | Instru√ß√£o |      ------
           -------------
```

### RDM e REM

* RDM (Registrador de Dados em Mem√≥ria): sendo o registrador que armazena os dados que est√£o sendo transmitidos da CPU e para a Mem√≥ria e vice-versa.

* REM (Registrador de Endere√ßos de Mem√≥ria): sua fun√ß√£o √© armazenar o endere√ßo de acesso √† mem√≥ria para que seja necess√°ria a leitura e a escrita de dados.

Tip:

Ambos os registradores possuem registro tempor√°rio dos dados que s√£o gravados neles.

```
    --------------
    | Barramento o-----|----------|
    |  Interno   |------|         |
    --------------      |         |
                     ---|---   ---|---
                     | RDM |   | REM |
                     -----|-   ---|---
                          |       |
                         -o-------o-
                         | Mem√≥ria |
                         -----------

o => significa o fluxo de dire√ß√£o dos dados
```



# 9 Barramentos

Barramentos s√£o as interconex√µes dos componentes computacionais.

## Tipos de Barramentos

S√£o divididos em tr√™s categorias:

* Estrutura * Dados * Endere√ßo * Controle

* Hierarquia * Local * Sistema * Expans√£o

### Estrutura

√â formado por tr√™s tipos seguintes de Barreamentos:

```
    CPU   MP  E/S
     |    |    |
--------------------  Barramnto Dados
     |    |    | 
-------------------- Barramento Endere√ßos
     |    |    |
-------------------- Barramento Controle
```

#### Barramento de Dados

Esse barramento interliga o RDM (Registrador de Dados em Mem√≥ria) com a mem√≥ria principal, para a transfer√™ncia de instru√ß√µes ou dados a serem executados.

Sendo um barramento bidirecional:
- J√° que pode tanto ir da CPU √† Mem√≥ria, assim realizando uma opera√ß√£o de escrita;
- E tamb√©m consegue ir da Mem√≥ria √† CPU, assim realizando uma opera√ß√£o de leitura.

A largura do barramento est√° diretamente ligada ao desempenho da m√°quina, j√° que quanto mais envio de dados (bits) maior ser√° a velocidade e poder de processamento, tal que, por consequ√™ncia, o desempenho ir√° aumentar. Os primeiros PCs continham apenas 8 bits de largura do seu barramento, hoje temos algo em torno ou maior que 128 bits.

#### Barramento de Endere√ßos

Feito para interligar o REM (Registrador de Endere√ßos de Mem√≥ria) com a Mem√≥ria Principal que ir√° fazer a transfer√™ncia de bits que v√£o representar endere√ßos de mem√≥ria das instru√ß√µes ou dados a serem executados.
Tem seu sentido unidirecional, j√° que somente a CPU aciona a mem√≥ria principal para fazer opera√ß√µes de leitura e escrita.

#### Barramento de Controle

Ir√° interligar a UC com os outros componentes.
Sendo bidirecional, pois consegue enviar sinais de controle para a Mem√≥ria e receber dela sinais do tipo wait (espere), para que possa terminar a execu√ß√£o da tarefa para come√ßar outra.

Assim, os barramentos compartilham os dados por vias que s√£o f√≠sicas, por meio de fios de cobre, e conectam todos os componentes.

### Hierarquia de Barramentos

A Hierarquia est√° ligada √† velocidade de tr√°fego desses barramentos.

#### Barramento Local ou Interno

√â o barramento mais r√°pido, j√° que est√° dentro da √°rea da CPU e funcionando no mesmo tempo do rel√≥gio do processador, ou seja, est√° na mesma velocidade de clock do processador.

#### Barramento Sistema

Tem por finalidade fazer a conex√£o entre o barramento local com os outros componentes do sistema, como por exemplo: mem√≥ria principal, cache L2, E/S. Ele faz uso do chipset norte da placa-m√£e.

Um Circuito Integrado (chipset) cuida de fazer a integra√ß√£o desse barramento deste modo:

```
|----------|
| Placa de |   |-----------|      |------| 
|  V√≠deo   |   | Mem√≥ria|  |      | CPU  |
|---|------|   | Principal |      |--|---|
    |          |-----|-----|         | 
    |                | Barramento    |
    |                | de Mem√≥ria    |
    |           |----|--|            |                         
    |-----------| Ponte |------------|
 Barramento     | Norte |   Barramento Externo
   AGPU         |-------|
```

#### Barramento de Expans√£o (ou E/S)

Sendo o barramento que interliga os dispositivos de E/S com os outros componentes do computador. Tal integra√ß√£o ocorre por meio do chipset (circuito integrado) chamado de: ponte sul.

```
 
         
         Barramento 
|------|    PCI     |-------|     
| Pont |------------- Algum |
| Sul  |            |  E/S  |
|--|---|            |-------| 
   |  
   | Barramento ATA ou IDE
   |
 |-|------|
 | Disco  |
 | Rigido |
 |--------|
```

Tip:

Em Discos Rigidos os dois tipos ATA e IDE podem ser integrados ir√° variar do tipo de memoria escolhida.

* ATA ![Pasted image 20240910104916.png](images/Pasted%20image%2020240910104916.png)

* IDE ![Pasted image 20240910105001.png](images/Pasted%20image%2020240910105001.png)

## Slots

Os slots nada mais s√£o que as entradas que os barramentos possuem (as boquinhas que t√™m na placa-m√£e para conectar os fios).
Os slots variam de acordo com o modelo da placa-m√£e.

![Pasted image 20240910105028](images/Pasted%20image%2020240910105028.png)



# 10 Representa√ß√£o de Dados

Um computador realiza uma execu√ß√£o sistematica de instru√ß√µes sobre valores, esses valores s√£o nomeados genericamente de:  dados. Tais valores s√£o c√≥digos b√≠narios (0 e 1).

```
processa
   |
   |
instru√ß√µes
   |
   |---valores
        |____ 0101
        |____ 11100
```

## Processo de Convers√£o

Para conversarmos com esses dados e o computador conversar conosco, usa-se um processo convers√£o de linguagens: linguagem do computador para a natural.
Sendo que:

* Alto nivel: temos as linguagens que os programadores usam para conversar com o PC * Linguagem natural (n√£o se usa binario e sim simbolos que se assemelham a linguagem humana) * Alto nivel de abstra√ß√£o

* Baixo Nivel: * Conversa diretamente com o computador, linguagem binaria (0 e 1) * Baixo nivel de abstra√ß√£o

## Formas de Representa√ß√£o

Tais formas variavam de acordo com as escolhas de qum desenvolve e com a plataforma que usa-se.
Podendo haver varia√ß√µes da forma como se define o tipo de dado a ser usado:

* Fortemente Tipada: deve ser definido os tipos de dados na hoa do desenvolvimento

* Fracamente Tipada: deixa essa responsabilidade de tipagem para o compilador da linguagem

## Tipos de Dados

Existem alguns tipos dados:

* integer: eles s√£o numeros inteiros, representados de formas variadas dependendo da linguagem, podendoter: 8bits, 16bits, 32bits e 64bits.

* real: s√£o numeros decimais e podem ser subdivididos em dois grupos: * float: menor precis√£o. * double: maior precis√£o.

* caractere (char): usad para representar apenas um caractre, sendo normalmente usado aspas simples para criar o char

* cadeia de caracteres (string): s√£o mais de um caractere entre aspas (sendo simples ou duplas)

* booleano: valore l√≥gicos que podm ser: true (verdadeiro ou 1) ou false (falso ou 0)

## Representa√ß√£o da Memoria

Pode-se dizr que a memoria funciona como um vetor, ela possui indices e neles tem seus valores. S√≥ que difrente de um vetor a memoria permite acesso direto e aleatorio dos indices e n√£o necessita de percorrer sequencialmente.

Tip:

O sistema de gerenciamento de memoria √© o programa que realiza a aloca√ß√£o de memoria e a coleta de lixo, logo a memoria RAM possui aloca√ß√µes e libra√ß√µes dinamicas.



# 12 Dispositivos de E/S

Os dispositivos de entrada e sa√≠da s√£o os respons√°veis por fazer essa integra√ß√£o da m√°quina com o humano, para que se possa tanto inserir dados quanto receber esses dados processados.
Possuindo as seguintes fun√ß√µes:

* Receber e enviar informa√ß√µes para o meio.

* Converter as informa√ß√µes recebidas e enviadas para possu√≠rem um formato intelig√≠vel para o computador e para o usu√°rio.

Exemplos: teclado, mouse, HD, SSD, etc.

## Classifica√ß√£o dos Dispositivos

### Entrada

Eles fornecem os dados, ou seja, um teclado √© um dispositivo de entrada.

### Sa√≠da

Eles exibem os dados, ou seja, um monitor √© um dispositivo de sa√≠da.

### Entrada e Sa√≠da

Eles realizam tanto a entrada quanto a sa√≠da de dados, uma impressora se enquadra nessa categoria, j√° que ela recebe o que se quer imprimir e gera a sa√≠da do material impresso.

## Comunica√ß√£o

Os dispositivos de E/S precisam se comunicar com a CPU, e para isso existem algumas tecnologias de comunica√ß√£o.

### Serial

* Envio de dados bit a bit.

```
 Gabinete
-----            --------------
| CPU |----------| Controlador | 
------           | ----------- |         ---------
                 |    Buffer   |--------| Teclado |
                  -------------          --------- 
```

* O controlador tamb√©m pode ser chamado de `driver`.

* Buffer: √© a √°rea que vai armazenar temporariamente e fazer a sincroniza√ß√£o de velocidade.

#### USB

Uma das formas de fazer a comunica√ß√£o de dispositivos √© o Universal Serial Bus (USB), possuindo alguns tipos, como:

* Micro USB: mais lento e comum em carregadores.

* USB-A: usado de forma muito comum para conectar laptops, desktops, etc.

* USB-C: r√°pido, carrega e pode-se usar os dois lados para carregar, por exemplo.

* USB-B: usado em impressoras.

#### Bluetooth

√â uma forma de conex√£o feita por ondas de r√°dio, simples, sem fio e r√°pida.

#### Wi-Fi

Conex√£o feita por sinais sem fio.

## Gerenciamento dos Dispositivos

Existem algumas formas de gerenciamento:

* Polling: antiga forma de gerenciamento, em que a CPU fica constantemente consultando os dispositivos de E/S para verificar se est√£o prontos ou precisando de aten√ß√£o.

* Interrup√ß√£o: a CPU fica ouvindo um dispositivo e, quando este terminar sua tarefa, ela ser√° interrompida para processar a solicita√ß√£o.

* DMA (Acesso Direto √† Mem√≥ria): permite o acesso direto √† mem√≥ria principal para transferir dados, sem a interven√ß√£o da CPU em cada processo.



